# Personalized UX

Сорцы самой библиотеки для переключения UI находятся в src. Примеры использования с vue и react в папках examples/vue и examples/react сответственно.

Библиотеку можно использовать двумя способами: 
1. Как пакет. Этот вариант использования показан в примере с реактом (разумеется на npm я не заливал, поэтому там непосредственный импорт из src, но сделать это не составит труда)
2. Как внешний скрпит. Этот вариант использования показан в примере с vue

# API

Кастомизация UI осушествляется посредством css-переменных. Библиотека осуществляет слежение за действиями пользователя и переопределяет css переменные когда классификатор принимает решение об изменении класса пользователя. 

## Инициализация 

```javascript
const { observe, observer } = UIPersonalizer({
  firstGroup: {
    triggerSelector: '.targer_group_1',
    theme: {
      background: '#34495e',
      'text-color': '#fff',
      'base-font-size': '16px',
    },
  },
  secondGroup: {
    triggerSelector: '.targer_group_2',
    theme: {
      background: '#fff',
      'text-color': '#000',
      'base-font-size': '14px',
    },
  },
});
```

Функция UIPersonalizer инициализирует библиотеку и возвращает объект с двумя свойствами - observer и observe.
Для того чтобы библиотека начала отслеживание пользовательских действий достаточно вызвать функцию observe. 

## Использование с динамическим DOM и кастомными событиями

При вызове функции observe на все DOM элементы, которые заматчатся по селекторам triggerSelector, переданным в функцию инициализации будут навешаны обработчики на событие 'click'.

Однако, может оказаться так, что целевые DOM элементы скрыты в момент первичной загрузки страницы (например находятся в модальных окнах). В этом случае, разработчик может добавить наблюдателей для отслеживания пользовательских действий динамически. Ниже приведет пример для реакта:

```tsx

const Modal = () => {
  const buttonRef = React.useRef(null)

  React.useEffect(() => {
    observer.addObserver('firstGroup', {
      element: buttonRef.current,
      event: 'click',
    })
    // отчищаем обработчики во избежание утечек памяти
    return () => {
      observer.clearObservers('firstGroup', {
        element: buttonRef.current,
        event: 'click',
      })
    }
  }, [buttonRef])

  return (
    <ModalHeader>
      Header
    </ModalHeader>
    <ModalContent>
      Content
    </ModalContent>
    <ModalAction>
      <button ref={buttonRef}>Click me!</button>
    </ModalAction>
  )
}
```

В данном примере, нажатия на кнопку будут расцениваться классификатором как действия пользователей из класса firstGroup.


# Запуск демо примеров

## Vue
```
$ cd ./example/vue
$ npm install
$ npm run serve
```

## React
```
$ cd ./example/react
$ npm install
$ npm run start
```

# Сведения о реализации

В основе реализации три класса и одна фукнция:
1. EventEmitter - кастомная реализация, предоставляющая API для вызова событий и подписки на них
2. UserObserver (наследует от EventEmitter) - класс для отслеживания пользовательских действий. Сами действия абстрактны и добавляются динамически
3. Classifier (наследует от EventEmitter) - абстрактный классификатор, подписывающийся на события UserObserver и классифицирующий пользователей на основании переданной в .use функции классификации
4. useRenderer - фукция, подписывающая переданную ей рендер функцию на событие классификации из Classifier

По сути данные классы представляют собой абстрактный мини-фреймворк для классификации пользователей на основании их действий. Конкретная классификация (исходя из параметров тестового задания) реализуется в точке входа. 

Все основные кейсы покрыты unit-тестами (mocha + chai + sinon + jsdom).

# Сборка 
Собрать скрипт в папку build
```
$ npm run build
```

Обновить скрипт в примере с vue
```
$ npm run build:vue
```

# Тесты
```
$ npm run test
```
```
$ npm run test:watch
```